#!/usr/bin/perl -wT
#
# Copyright (c) 2008-2011 University of Utah and the Flux Group.
# 
# {{{EMULAB-LICENSE
# 
# This file is part of the Emulab network testbed software.
# 
# This file is free software: you can redistribute it and/or modify it
# under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or (at
# your option) any later version.
# 
# This file is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public
# License for more details.
# 
# You should have received a copy of the GNU Affero General Public License
# along with this file.  If not, see <http://www.gnu.org/licenses/>.
# 
# }}}
#
use strict;
use English;
use Getopt::Std;

#
# Report network traffic from nodes' control network.
#
sub usage()
{
    print STDERR "Usage: node_traffic [-aArsE] [-i seconds] [node...]\n";
    print STDERR "Reports traffic from nodes on the control network.\n";
    print STDERR "-h         This message\n";
    print STDERR "-a         Show all nodes regardless of node state\n";
    print STDERR "-A         Really all; includes free nodes as well\n";
    print STDERR "-r	     Show only traffic received by each node\n";
    print STDERR "-s	     Show only traffic sent by each node\n";
    print STDERR "-i seconds Show stats over a <seconds>-period interval\n";
    print STDERR "-E	     Aggregate by experiment\n";
#    print STDERR "-C	     Show control net traffic\n";
    exit(-1);
}

sub gather($$);

my $optlist  = "CEi:aArs";
my $debug = 0;
my $interval = 0;
my $doall = 0;
my $send = 1;
my $recv = 1;
my $byexpt = 0;

# XXX only does control net right now
my $controlnet = 1;

#
# Configure variables
#
#my $TB = "@prefix@";
my $TB = "/usr/testbed";

#
# Testbed Support libraries
#
#use lib "/usr/testbed/lib";
use lib "@prefix@/lib";
use libdb;

#
# Turn off line buffering on output
#
$| = 1;

#
# Untaint the path
# 
$ENV{'PATH'} = "/bin:/sbin:/usr/bin:";
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

#
# 
#
my $portstats	= "$TB/bin/portstats";
my @nodes       = ();
my %switches	= ();
my %pcs		= ();

#
# Parse command arguments. Once we return from getopts, all that should be
# left are the required arguments.
#
my %options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (defined($options{"h"})) {
    usage();
}
if (defined($options{"a"})) {
    $doall = 1;
}
if (defined($options{"A"})) {
    $doall = 2;
}
if (defined($options{"r"})) {
    $recv = 1;
    $send = 0;
}
if (defined($options{"s"})) {
    $recv = 0;
    $send = 1;
}
if (defined($options{"i"})) {
    $interval = int($options{"i"});
    if ($interval < 0) {
	die("Bogus interval $interval\n");
    }
}
if (defined($options{"E"})) {
    $byexpt = 1;
}
if (defined($options{"C"})) {
    $controlnet = 1;
}

@nodes = @ARGV;

#
# No nodes specified, get stats for all nodes that are in an experiment.
#
my $nclause = "";
if (@nodes > 0) {
	$nclause = "and n.node_id in (" . join(",", map("'$_'", @nodes)) . ")";
}

my $query_result;

if ($doall == 2) {
    $query_result =
	DBQueryWarn("select r.pid,r.eid,node_id1,eventstate,card1,port1,node_id2".
		    " from wires as w,nodes as n".
		    " left join reserved as r on n.node_id=r.node_id".
		    " where w.node_id1=n.node_id".
		    "  and (node_id2 like 'cisco%' or node_id2 like 'procurve%')".
		    "  and w.type='Control'".
		    "  and n.role='testnode' $nclause".
		    " order by node_id2,card2,port2");
} else {
    $query_result =
	DBQueryWarn("select r.pid,r.eid,node_id1,eventstate,card1,port1,node_id2".
		    " from wires as w,nodes as n,reserved as r".
		    " where w.node_id1=n.node_id and w.node_id1=r.node_id".
		    "  and (node_id2 like 'cisco%' or node_id2 like 'procurve%')".
		    "  and w.type='Control'".
		    "  and n.role='testnode' $nclause".
		    " order by node_id2,card2,port2");
}
if (! $query_result || $query_result->numrows == 0) {
    print STDERR "Node(s) not found.\n";
    exit(0);
}
while (my %row = $query_result->fetchhash()) {
    my $switch = $row{'node_id2'};
    my $pc = $row{'node_id1'};
    my $pceth = $row{'card1'};
    my $pcport = $row{'port1'};
    my $exp;
    if (defined($row{'pid'})) {
	$exp = $row{'pid'} . "/" . $row{'eid'};
    } else {
	$exp = "<NONE>";
    }

    #
    # XXX ugh, portstats only takes node:card and not node:card.port,
    # so if the port is anything other than 1 (e.g., an allocable switch)
    # we cannot look it up.
    #
    next
	if ($pcport != 1);

    my $cnet = "$pc:$pceth";

    push(@{$switches{$switch}}, $cnet);
    $pcs{$cnet}{'exp'} = $exp;
    $pcs{$cnet}{'state'} = $row{'eventstate'};
}

my %before = ();
if ($interval > 0) {
    gather(\%pcs, \%before);
    print STDERR "Waiting $interval seconds ...\n";
    sleep($interval);
}
my %after = ();
gather(\%pcs, \%after);

my %expcounts = ();

# weed out bad boys
my @list = ();
foreach my $node (keys %pcs) {
    if (!exists($after{$node}{'counts'})) {
	print STDERR "*** $node: got no portstats!?\n";
	next;
    }

    # XXX
    if (!exists($before{$node})) {
	$before{$node}{'totals'} = [ 0, 0, 0, 0 ];
    }

    if (!$doall && $pcs{$node}{'state'} ne "ISUP") {
	print STDERR "*** $node: not up (", $pcs{$node}{'state'}, ")\n";
	next;
    }
    my $total = $after{$node}{'totals'}->[3] - $before{$node}{'totals'}->[3];
    if ($total <= 0) {
	print STDERR "*** $node: negative packet count (",
	             $before{$node}{'totals'}->[3], " to ",
		     $after{$node}{'totals'}->[3], " ($total)\n"
			 if ($total < 0);
	next;
    }
    $pcs{$node}{'total'} = $total;
    push(@list, $node);

    if ($byexpt) {
	my $cb = $before{$node}{'totals'};
	my $ca = $after{$node}{'totals'};
	my $exp = $pcs{$node}{'exp'};
	if (!exists($expcounts{$exp})) {
	    $expcounts{$exp} = [ 0, 0, 0, 0 ];
	}
	$expcounts{$exp}->[0] += ($ca->[0] - $cb->[0]);
	$expcounts{$exp}->[1] += ($ca->[1] - $cb->[1]);
	$expcounts{$exp}->[2] += ($ca->[2] - $cb->[2]);
	$expcounts{$exp}->[3] += ($ca->[3] - $cb->[3]);
    }
}

if ($byexpt) {
    printf("%25s %12s %12s %12s %12s\n",
	   "Experiment", "Tot Pkts", "Unicast", "Non-Uni", "Tot Bytes");
    foreach my $exp (sort esortem keys %expcounts) {
	printf("%25s %12d %12d %12d %12d\n",
	       $exp, $expcounts{$exp}->[3],
	       $expcounts{$exp}->[1],
	       $expcounts{$exp}->[2],
	       $expcounts{$exp}->[0]);
    }
} else {
    @list = sort sortem @list;

    printf("%12s %25s %12s %12s %12s %12s\n",
	   "Node", "Experiment", "Tot Pkts", "Unicast", "Non-Uni", "Tot Bytes");
    foreach my $node (@list) {
	my $cb = $before{$node}{'totals'};
	my $ca = $after{$node}{'totals'};
	my $exp = $pcs{$node}{'exp'};
	my $s = $pcs{$node}{'state'};

	printf("%12s %25s %12d %12d %12d %12d\n",
	       $node, $exp,
	       $ca->[3]-$cb->[3], $ca->[1]-$cb->[1],
	       $ca->[2]-$cb->[2], $ca->[0]-$cb->[0]);
    }
}

sub esortem($$)
{
    my ($a, $b) = @_;

    my $atot = $expcounts{$a}->[3];
    my $btot = $expcounts{$b}->[3];
    return $btot <=> $atot;
}

sub sortem($$)
{
    my ($a, $b) = @_;

    my $atot = $pcs{$a}{'total'};
    my $btot = $pcs{$b}{'total'};
    return $btot <=> $atot;
}

sub gather($$)
{
    my ($pcref, $resref) = @_;

    foreach my $switch (keys %switches) {
	my $slist = join(' ', @{$switches{$switch}});
	open(PS, "$portstats -p $slist 2>&1 |") or
	    die "Could not get portstats\n";
	while (<PS>) {
	    next if ($_ !~ /^\w+:\d/);
	    my ($node, @counts) = split;
	    if (@counts != 6) {
		print STDERR "*** $node: invalid portstats!?\n"; 
		next;
	    }

	    #
	    # XXX portstats returns nodes in the format: pcXXX:N.N,
	    # even though it won't accept that format on the command line!
	    #
	    if ($node =~ /^(.*:\d+)\.\d$/) {
		$node = $1;
	    }

	    if (!exists($pcref->{$node})) {
		print STDERR "*** $node: no stats returned!?\n"; 
		next;
	    }
	    $resref->{$node}{'counts'} = @counts;
	    my $oct = 0;
	    my $upkts = 0;
	    my $npkts = 0;
	    if ($send) {
		$oct += $counts[0];
		$upkts += $counts[1];
		$npkts += $counts[2];
	    }
	    if ($recv) {
		$oct += $counts[3];
		$upkts += $counts[4];
		$npkts += $counts[5];
	    }
	    $resref->{$node}{'totals'} =
		[ $oct, $upkts, $npkts, $upkts + $npkts ];
	}
	close(PS);
    }
}

exit(0);
