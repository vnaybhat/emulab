#!/usr/bin/perl -w
#
# Copyright (c) 2012-2014 University of Utah and the Flux Group.
# 
# {{{EMULAB-LICENSE
# 
# This file is part of the Emulab network testbed software.
# 
# This file is free software: you can redistribute it and/or modify it
# under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or (at
# your option) any later version.
# 
# This file is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public
# License for more details.
# 
# You should have received a copy of the GNU Affero General Public License
# along with this file.  If not, see <http://www.gnu.org/licenses/>.
# 
# }}}
#
use English;
use strict;
use Getopt::Std;
use File::stat;

#
# Get basic info for an image.
#
# This is intended for use by non-admin process on boss which might have
# Emulab-permitted download access but not physical access to the image
# (i.e., it is a shared image). Uses the frisbee mserver to get the info.
#

sub usage()
{
    print("Usage: imageinfo [-N nodeid] [-s] [-m] <imageid>\n" .
	  "Options:\n".
	  "   -d        Turn on debug mode\n".
	  "   -N nodeid Use the frisbee master server to get info on behalf of nodeid\n".
	  "   -q        Don't print message on error, just exit non-zero\n".
	  "   -s        Just print the size of the image in bytes\n".
	  "   -m        Just print the modtime of the image in seconds since epoch\n".
	  "   -r	Print the range of sectors covered by the image\n");
    exit(-1);
}
my $optlist   = "dsmN:qr";
my $debug     = 0;
my $quiet     = 0;
my $showall   = 1;
my $showsize  = 0;
my $showmtime  = 0;
my $showrange = 0;
my $nodeid;

#
# Configure variables
#
my $TB		= "@prefix@";
my $frisbee	= "$TB/sbin/frisbee";
my $imagedump	= "$TB/bin/imagedump";

# Protos
sub fatal($);

#
# Untaint the path
#
$ENV{'PATH'} = "$TB/bin:$TB/sbin:/bin:/usr/bin:/usr/bin:/usr/sbin";
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

#
# Turn off line buffering on output
#
$| = 1;

#
# Load the Testbed support stuff.
#
use lib "@prefix@/lib";
use Node;
use Image;

#
# Parse command arguments. Once we return from getopts, all that should be
# left are the required arguments.
#
my %options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (defined($options{"d"})) {
    $debug = 1;
}
if (defined($options{"q"})) {
    $quiet = 1;
}
if (defined($options{"s"})) {
    $showsize = 1;
    $showall = $showmtime = $showrange = 0;
}
if (defined($options{"m"})) {
    $showmtime = 1;
    $showall = $showsize = $showrange = 0;
}
if (defined($options{"r"})) {
    $showrange = 1;
    $showall = $showsize = $showmtime = 0;
}
if (defined($options{"N"})) {
    my $node = Node->Lookup($options{"N"});
    if (!defined($node)) {
	fatal("No such node exists");
    }
    $nodeid = $node->node_id();
}
usage() 
    if (@ARGV != 1);

my $image   = Image->Lookup($ARGV[0]);
if (!defined($image)) {
    fatal("No such image exists");
}
my $imagename = $image->imagename();
my $imagepid = $image->pid();
my $imagepath = $image->path();
    
if (! -R $imagepath) {
    if (!defined($nodeid)) {
	fatal("$imagepid/$imagename: image file is not readable, ".
	      "must use -N\n");
    }
    if ($showrange) {
	fatal("$imagepid/$imagename: image file is not readable, ".
	      "cannot determine sector range\n");
    }
}

my ($isize, $imtime, $secmin, $secmax, $relocatable);

#
# Use imagedump to get the sector range and whether the image is relocatable.
# It prints:
# ...
#   1 relocations covering 276 bytes
#   covered sector range: [0-12305790]
# ...
# Note that even if an image has no relocations, it might still be relocatable.
# But, this is the best we can do!
#
$relocatable = 0;
if ($showrange) {
    if (-x $imagedump) {
	foreach my $line (`$imagedump $imagepath 2>&1`) {
	    if ($line =~ /covered sector range: \[(\d+)-(\d+)\]/) {
		$secmin = $1;
		$secmax = $2;
		next;
	    }
	    if ($line =~ /(\d+) relocations covering/) {
		if ($1 > 0) {
		    $relocatable = 1;
		}
		next;
	    }
	}
    }
    if (!defined($secmin)) {
	fatal("$imagepid/$imagename: could not determine sector range ".
	      "from imagefile $imagepath\n");
    }
}

if (!defined($nodeid)) {
    print STDERR "Doing stat on $imagepath\n"
	if ($debug);
    $isize = stat($imagepath)->size;
    $imtime = stat($imagepath)->mtime;
} else {
    print STDERR "Using frisbee on $imagepid/$imagename\n"
	if ($debug);
    my $attr = `$frisbee -S localhost -Q $imagepid/$imagename -P $nodeid`;
    if ($attr =~ /error=0/) {
	if ($attr =~ /size=(\d+)/) {
	    $isize = $1;
	}
	if ($attr =~ /sigtype=0x1/ && $attr =~ /sig=(0x[0-9a-f]+)/) {
	    $imtime = hex($1);
	}
    } else {
	fatal("$imagepid/$imagename: access not allowed or image does not exist");
    }
}

if ($showall) {
    if (defined($isize)) {
	printf "size=%lu\n", $isize;
    }
    if (defined($imtime)) {
	printf "mtime=%lu\n", $imtime;
    }
} elsif ($showsize && defined($isize)) {
    printf "%lu\n", $isize;
} elsif ($showmtime && defined($imtime)) {
    printf "%lu\n", $imtime;
} elsif ($showrange && defined($secmin)) {
    printf "minsect=%lu\n", $secmin;
    printf "maxsect=%lu\n", $secmax;
    printf "secsize=512\n";
    printf "relocatable=%d\n", $relocatable;
}

exit(0);

sub fatal($)
{
    my ($mesg) = $_[0];

    exit(-1)
	if ($quiet);

    die("*** $0:\n".
	"    $mesg\n");
}
