#!/usr/bin/perl -wT
#
# Copyright (c) 2000-2014 University of Utah and the Flux Group.
# 
# {{{EMULAB-LICENSE
# 
# This file is part of the Emulab network testbed software.
# 
# This file is free software: you can redistribute it and/or modify it
# under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or (at
# your option) any later version.
# 
# This file is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public
# License for more details.
# 
# You should have received a copy of the GNU Affero General Public License
# along with this file.  If not, see <http://www.gnu.org/licenses/>.
# 
# }}}
#
use strict;
use English;
use Getopt::Std;
use POSIX qw(setsid :sys_wait_h);
use File::Basename;
use Cwd qw(realpath);

#
# Image Creation Tuneables.
#
# $maxwait	Max total wall clock time to allow for image collection.
#		We abort after this length of time even if we are still
#		actively making progress collecting the image.
#		Empirically we have observed about 1.6MB/sec on a pc850
#		for a Windows image (the slowest to create), so figuring
#		1.5MB/sec for a 6GB max image works out to around 72 minutes.
#		This value comes from sitevar images/create/maxwait if set.
#
# $idlewait	Max time to allow between periods of progress.
#		This value ensures that if we get stuck and stop making
#		progress, we don't have to wait the potentially very long
#		time til the $maxwait time expires to notice and abort.
#		This value comes from sitevar images/create/idlewait if set.
#
# $checkwait	Time between progress checks (must be int div of $idlewait)
#		Hardwired here, does not come from DB.
#
# $reportwait	Time between progress reports (must be multiple of $checkwait)
#		Hardwired here, does not come from DB.
#
# $maximagesize	Max size in bytes of an image.  Currently this is site-wide
#		and comes from sitevar images/create/maxsize if set. It should
#		probably be finer-grained (per-project? per-user?) than that.
#
my $maxwait      = (72 * 60);
my $idlewait     = ( 8 * 60);
my $reportwait   = ( 2 * 60);
my $checkwait    = 15;
my $maximagesize = (6 * 1024**3);

#
# Options for imagezipper on the client-side. These apply only to imagezip,
# i.e., the local node imaging process. They also only apply to the latest
# version of the client script (create-versioned-image). For the older path,
# options are hardwired into the create-image script.
#
# Note that since we cannot have spaces in the string passed to the client,
# options are encoded; e.g.:
#   -N -z 9 -d -a SHA1
# would be encoded as:
#   N,z=9,d,a=SHA1
#
# Specific options:
#
# By default we do not create relocations (-N) in the resulting image for a
# couple of reasons. One is that we never did relocation support for GRUB
# partition boot code, so modern Linux images would not have relocations
# anyway. For FreeBSD this does mean that we cannot relocate them (we use
# a relocation for correct disklabel construction), but we never really
# took advantage of this anyway. The second reason is that ranges with
# relocations are always considered different for hash comparisons, so an
# otherwise empty FreeBSD delta image would have 64K of data in it.
#
my $zipperopts = "N";

#
# Create a disk image.
#
# XXX: Device file should come from DB.
#      Start/count slice computation is not generalized at all.
#
sub usage()
{
    print(STDERR
	  "Usage: create_image [-wsN] [-p <pid>] <imagename> <node>\n" .
	  "switches and arguments:\n".
	  "-w          - wait for image to be fully created\n".
	  "-s          - use ssh instead of frisbee uploader\n".
	  "-N          - use NFS (if available) instead of frisbee uploader\n".
	  "-F          - create a full image even if deltas are on\n".
	  "-D          - create a 'delta' image rather than a full image\n".
	  "-S          - create a signature file for the new image\n".
	  "-A <pct>    - when -D is specified, automatically create a full\n".
	  "              image instead when a delta would be more than\n".
	  "              <pct> percent the size of a full image.\n".
	  "-M          - do not boot info MFS, run with ssh from current OS\n".
	  "-p <pid>    - project ID of the image; defaults to system project\n".
	  "<imagename> - imagename to use\n".
	  "<node>      - nodeid to create the image from\n");
    exit(-1);
}
my $optlist  = "p:wsNdfeDSMA:F";
my $waitmode = 0;
my $usessh   = 0;
my $usenfs   = 0;
my $usefup   = 1;
my $noemail  = 0;
my $delta    = 0;
my $nodelta  = 0;
my $nomfs    = 0;
my $signature= 0;
my $deltapct = 0;
my $webtask;

#
# Configure variables
#
my $TB		= "@prefix@";
my $TBOPS       = "@TBOPSEMAIL@";
my $TBLOGS      = "@TBLOGSEMAIL@";
my $BOSSIP	= "@BOSSNODE_IP@";
my $CONTROL     = "@USERNODE@";
my $NONFS	= @NOSHAREDFS@;
my $WITHPROVENANCE= @IMAGEPROVENANCE@;
my $WITHDELTAS  = @IMAGEDELTAS@;
my $ISFS        = ("@BOSSNODE_IP@" eq "@FSNODE_IP@") ? 1 : 0;

#
# Testbed Support libraries
#
use lib "@prefix@/lib";
use libdb;
use EmulabConstants;
use libtestbed;
use libadminmfs;
use Experiment;
use Node;
use User;
use Image;
use OSinfo;
use Logfile;
use WebTask;
use Project;
use EmulabFeatures;

#
# Turn off line buffering on output
#
$| = 1;

#
# Untaint the path
# 
$ENV{'PATH'} = "/bin:/sbin:/usr/bin:";
delete @ENV{'IFS', 'CDPATH', 'ENV', 'BASH_ENV'};

#
# We don't want to run this script unless its the real version.
#
if ($EUID != 0) {
    die("*** $0:\n".
	"    Must be setuid! Maybe its a development version?\n");
}

sub cleanup();
sub fatal($);
sub check_progress($$);
sub run_with_ssh($$);

my $nodereboot	= "$TB/bin/node_reboot";
my $createimage = "/usr/local/bin/create-versioned-image";
my $createxenimage = "/usr/local/bin/create-xen-image";
my $ocreateimage= "/usr/local/bin/create-image";
my $reboot_prep = "@CLIENT_BINDIR@/reboot_prepare";
my $EC2SNAP     = "$TB/sbin/ec2import.proxy";
my $friskiller  = "$TB/sbin/frisbeehelper";
my $osselect    = "$TB/bin/os_select";
my $checkquota  = "$TB/sbin/checkquota";
my $imagehash	= "$TB/bin/imagehash";
my $imagevalidate = "$TB/sbin/imagevalidate";
my $SHA1	= "/sbin/sha1";
my $SCP		= "/usr/bin/scp";
my $def_devtype	= "ad";
my $def_devnum	= 0;
my $devtype;
my $devnum;
my $device;
my $mereuser    = 0;
my $debug       = 1;
my $foreground  = 0;
my $imagepid    = TB_OPSPID;
my $logfile;
my $oldlogfile;
my $needcleanup = 0;
my $needunlock  = 0;
my $isvirtnode  = 0;
my $isxenhost   = 0;
my $isec2node   = 0;
my $onsharednode= 0;
my $didbackup   = 0;
my $node_id;
my $node;
my ($experiment,$pid);
my $doprovenance = 0;
my $hacksigfile;

#
# Parse command arguments. Once we return from getopts, all that should be
# left are the required arguments.
#
my %options = ();
if (! getopts($optlist, \%options)) {
    usage();
}
if (defined($options{"w"})) {
    $waitmode = 1;
}
if (defined($options{"e"})) {
    $noemail = 1;
}
if (defined($options{"s"})) {
    $usessh = 1;
    $usefup = $usenfs = 0;
}
if (defined($options{"N"})) {
    if (!$NONFS) {
	$usenfs = 1;
	$usefup = $usessh = 0;
    } else {
	print STDERR "NFS not available, cannot use -N\n";
	exit(1);
    }
}
if (defined($options{"d"})) {
    $debug = 1;
}
if (defined($options{"f"})) {
    $foreground = 1;
    $waitmode = 0;
}
if (defined($options{"D"})) {
    if (!$WITHDELTAS) {
	print STDERR "Delta image support not enabled\n";
	exit(1);
    }
    $delta = 1;
}
if (defined($options{"S"})) {
    if (!$WITHDELTAS) {
	print STDERR "Delta image support not enabled\n";
	exit(1);
    }
    $signature = 1;
}
if (defined($options{"M"})) {
    $nomfs = 1;
    $usessh = 1;
}
if (defined($options{"A"})) {
    if (!$WITHDELTAS) {
	print STDERR "Delta image support not enabled\n";
	exit(1);
    }
    if ($options{"A"} =~ /^(\d+)$/) {
	$deltapct = int($1);
    } else {
	print STDERR "Invalid percentage for -A\n";
	exit(1);
    }
}
if (defined($options{"F"})) {
    $nodelta = 1;
}
if (@ARGV != 2) {
    usage();
}

my $imagename  = $ARGV[0];
my $target     = $ARGV[1];

#
# There is no reason to run as root unless we are taking a snapshot
# of a VM on a shared node. In that case we will flip back when
# we do the ssh over.
#
$EUID = $UID;

#
# Untaint the arguments.
#
if ($imagename =~ /^([-\w\.\+:]+)$/) {
    $imagename = $1;
}
else {
    die("*** $0:\n".
	"    Bad data in $imagename.\n");
}
    
if (defined($options{"p"})) {
    $imagepid = $options{"p"};
	
    if ($imagepid =~ /^([-\w\.]+)$/) {
	$imagepid = $1;
    }
    else {
	die("*** $0:\n".
	    "    Bad data in $imagepid.\n");
    }
}

#
# Reset default values from site variables if they exist.
#
my $tmp;
if (TBGetSiteVar("images/create/maxwait", \$tmp)) {
    $maxwait = $tmp * 60;
}
if (TBGetSiteVar("images/create/idlewait", \$tmp)) {
    $idlewait = $tmp * 60;
}
if (TBGetSiteVar("images/create/maxsize", \$tmp)) {
    $maximagesize = $tmp * 1024**3;
}
$idlewait = $maxwait
    if ($maxwait < $idlewait);
$reportwait = $idlewait
    if ($idlewait < $reportwait);
$checkwait = $reportwait
    if ($reportwait < $checkwait);

#
# Verify user and get his DB uid and other info for later.
#
my $this_user = User->ThisUser();
if (! defined($this_user)) {
    die("You ($UID) do not exist!\n");
}
my $user_uid   = $this_user->uid();
my $user_name  = $this_user->name();
my $user_email = $this_user->email();

if ($UID && ! $this_user->IsAdmin()) {
    $mereuser = 1;
}

#
# Grab the imageid description from the DB. We do a permission check, but
# mostly to avoid hard to track errors that would result if the user picked
# the wrong one (which is likely to happen no matter what I do).
#
my $image = Image->Lookup($imagepid, $imagename);
if (!defined($image)) {
    die("*** $0:\n".
	"    No such image descriptor $imagename in project $imagepid!\n");
}
my $imageid = $image->imageid();
my $version = $image->version();
$imagename  = $image->imagename(); # strip any version

if ($mereuser &&
    ! $image->AccessCheck($this_user, TB_IMAGEID_ACCESS)) {
    die("*** $0:\n".
	"    You do not have permission to use imageid $imageid!\n");
}

#
# Before doing anything else, check for overquota ... lets not waste
# our time. Make sure user sees the error by exiting with 1.
#
if (system("$checkquota -p $imagepid $user_uid") != 0) {
    die("*** $0:\n".
	"    You are over your disk quota on $CONTROL; ".
	"please login there and cleanup!\n");
}

#
# See if per-project/per-user provenance feature is set.
#
if ($WITHPROVENANCE) {
    my $project = Project->Lookup($image->pid());
    if (!defined($project)) {
	die("*** $0:\n".
	    "    Could not lookup project for $image\n");
    }

    # But allow feature override. 
    $doprovenance = EmulabFeatures->FeatureEnabled("ImageProvenance",
						   $this_user, $project);
    
    # Temporary override for all geni projects until we can export deltas.
    if ($project->IsNonLocal()) {
	my $feature = EmulabFeatures->Lookup("ImageProvenance");
	if ($feature && $feature->enabled()) {
	    # If globally enabled, disable. If not globally enabled but
	    # doprovenance is on, then it was a per-project enable which
	    # we wanr to respect.
	    $doprovenance = 0;
	}
    }
}

#
# When provenance is enabled and we have delta support, we always collect
# signatures and we always try to create deltas. Note that we set them to
# a different non-zero value so we can distinguish this case and not print
# various warnings below.
#
# XXX We really shouldn't be doing this implicitly--our caller should just
# be specifying the options when provenance is enabled--but this script is
# called from a surprisingly large number of places, so we do!
#
if ($doprovenance && $WITHDELTAS) {
    $delta = 2
	if ($delta == 0);
    $signature = 2
	if ($signature == 0);

    # XXX let's try this for now
    $deltapct = 50
	if ($deltapct == 0);

    # Override delta but still collect signatures. 
    $delta = 0
	if ($image->nodelta() || $nodelta);
}

my ($srcsigfile, $srcimage, $dstsigfile);

#
# Is it a local node or a remote EC2 node (need to generalize). 
#
if ($target =~ /^.*@.*$/) {
    if ($target =~ /^([-\w\@\+\.]+)$/) {
	$target = $1;
    }
    else {
	die("*** $0:\n".
	    "    Bad data in $target\n");
    }

    if ($delta || $signature) {
	# Only warn if they explicitly specified an option
	if ($delta == 1 || $signature == 1) {
	    print STDERR
		"*** WARNING: don't support delta imaging of EC2 images, ".
		"ignoring delta/signature options.\n";
	}
	$delta = $signature = 0;
    }

    $isec2node = 1;
    $usefup = $usessh = 0;
    $pid = $image->pid();
}
else {
    if ($target =~ /^([-\w]+)$/) {
	$node_id = $1;
    }
    else {
	die("*** $0:\n".
	    "    Bad data in $target\n");
    }

    # Check node and permission
    $node = Node->Lookup($node_id);
    if (!defined($node)) {
	die("*** $0:\n".
	    "    Invalid node name $node_id!\n");
    }
    $isvirtnode   = $node->isvirtnode();
    $onsharednode = $node->sharing_mode()
	if ($isvirtnode);

    if (! $node->AccessCheck($this_user, TB_NODEACCESS_LOADIMAGE)) {
	die("*** $0:\n".
	    "    You do not have permission to create an image from $node\n");
    }

    if ($node->IsTainted()) {
	die("*** $0:\n".
	    "    $node is tainted - image creation denied.\n");
    }

    #
    # We need the project id for test below. The target directory for the
    # output file has to be the node project directory, since that is the
    # directory that is going to be NFS mounted by default.
    #
    $experiment = $node->Reservation();
    if (!defined($experiment)) {
	die("*** $0:\n".
	    "    Could not map $node to its experiment object!\n");
    }
    $pid = $experiment->pid();

    if ($isvirtnode) {
	#
	# Need to know this is a xen-host to tailor method below.
	#
	my $pnode  = Node->Lookup($node->phys_nodeid());
	my $osinfo = OSinfo->Lookup($pnode->def_boot_osid());
	if (!defined($osinfo)) {
	    fatal("Could not get osinfo for $pnode");
	}
	if ($osinfo->FeatureSupported("xen-host")) {
	    $isxenhost = 1;

	    if ($image->mbr_version() == 99) {
		$doprovenance = $delta = $signature = 0;
	    }
	}
    }

    # Do not create a delta for system images but still collect signatures.
    $delta = 0
	if ($pid eq TBOPSPID());

    #
    # If we are creating a delta image, figure out what image we are
    # deriving from so that we can grab the signature.
    #
    if ($delta) {
	#
	# Find the source image we are creating a delta from. When provenance
	# is enabled, we can use the parent image. If not enabled, we attempt
	# to determine what is already on the node via the partitions table.
	#
	# If we cannot determine the source, we just warn and create a full
	# image instead.
	#
	if ($doprovenance) {
	    $srcimage = $image->Parent();
	}
	if (!defined($srcimage)) {
	    (undef, $srcimage) = $node->RunningOsImage();
	}
	if (defined($srcimage)) {
	    $srcsigfile = $srcimage->path() . ".sig";
	    if (! -e "$srcsigfile") {
		# XXX user may not have direct access to a shared image
		my $SAVEUID = $UID;
		$EUID = $UID = 0;
		if (! -e "$srcsigfile") {
		    $srcsigfile = undef;
		}
		$EUID = $UID = $SAVEUID;
	    }
	    if (!defined($srcsigfile)) {
		if ($delta == 1) {
		    print "*** WARNING: no signature file for source image, ".
			"cannot create delta; creating full image instead.\n";
		}
		$delta = 0;
	    }
	} else {
	    if ($delta == 1) {
		print "*** WARNING: no source for image, ".
		    "cannot create delta; creating full image instead.\n";
	    }
	    $delta = 0;
	}
    }

    #
    # If we are creating a signature file for this image, look up the path
    # so we derive the signature file name.
    #
    if ($signature) {
	if (defined($image->path())) {
	    $dstsigfile = $image->path() . ".sig";
	} else {
	    if ($signature == 1) {
		print "*** WARNING: no path for image, ".
		    "cannot create signature file.\n";
	    }
	    $signature = 0;
	}
    }

    #
    # To avoid blowing a cavernous hole ("allow all TCP ports to boss")
    # in the per-experiment firewall, we don't use the frisbee uploader if
    # the node is firewalled.
    # 
    if ($usefup && $experiment->IsFirewalled()) {
	print "*** WARNING: $node_id is firewalled, not using Frisbee uploader\n";
	$usefup = 0;
	if ($NONFS) {
	    $usenfs = 0;
	    $usessh = 1;
	} else {
	    $usenfs = 1;
	    $usessh = 0;
	}
    }
}

#
# Make sure that the directory exists and is writeable for the user.
# We test this by creating the file. Its going to get wiped anyway.
#
my $filename = $image->path();
my $isglobal = $image->global();
my $usepath  = 0;

#
# Redirect pathname for global images. See equiv code in clone_image.
# XXX if the project of the experiment creating the image is not emulab-ops,
# we make a feeble attempt to avoid clobbering existing files.
#
my $hackprefix;
if ($pid eq TBOPSPID()) {
    $hackprefix = PROJROOT() . "/$pid/images/";
} else {
    $hackprefix = PROJROOT() . "/$pid/images/E_O_";
}
if ($isglobal && ($filename =~ /^$TB/)) {
    $filename = $hackprefix . basename($filename);
    print "*** WARNING: Writing global descriptor to $filename instead!\n";

    #
    # Ditto for the signature file
    #
    if ($dstsigfile && ($dstsigfile =~ /^$TB/)) {
	$dstsigfile = $hackprefix . basename($dstsigfile);
    }

    #
    # XXX the Emulab config of the master server doesn't know this trick
    # so when it tries to lookup imageid emulab-ops/<whatever> it would
    # still map to /usr/testbed and fail because it cannot update images
    # outside of /{users,group,proj}. So we skirt the issue by passing
    # it the full path contructed here rather than the imageid.
    #
    $usepath = 1;
}

#
# For the source signature file, we actually have to copy it to
# somewhere where we can read it as well as just fixup the path.
#
if ($srcsigfile && ($srcsigfile =~ /^$TB/)) {
    my $osrcsigfile = $srcsigfile;
    $srcsigfile = $hackprefix . basename($srcsigfile);
    if (system("cp -fp $osrcsigfile $srcsigfile")) {
	die("*** $0:\n".
	    "    Could not copy source signature file ".
	    "$osrcsigfile to $srcsigfile\n");
    }
    # XXX remember so we can cleanup later
    $hacksigfile = $srcsigfile;
}

#
# Make sure real path is someplace that makes sense; remember that the
# image is created on the nodes, and it NFS mounts directories on ops.
# Writing the image to anyplace else is just going to break things.
#
# Use realpath to validate the path. The still use the original path
# for passing to the client-side since boss and the client may not have
# the same real path for a file.
#
my $ofilename = $filename;
my $translated = realpath($filename);
if ($translated =~ /^([-\w\.\/\+:]+)$/) {
    $filename = $1;
}
else {
    die("*** $0:\n".
	"    Bad data returned by realpath: $translated\n");
}
# Make sure not a directory.
if (-d $filename) {
    die("*** $0:\n".
	"    $filename is a directory! Must be a plain file.\n");
}

#
# The file must reside in an allowed directory. Since this script
# runs as the caller, regular file permission checks ensure its a file
# the user is allowed to use. 
#
if (! TBValidUserDir($filename, $ISFS)) {
    die("*** $0:\n".
	"    $filename does not resolve to an allowed directory!\n");
}

#
# Before we do anything destructive, we lock the image.
#
if ($image->Lock()) {
    die("*** $0:\n".
	"    Image is locked, please try again later!\n");
}
$needunlock = 1;

if ($doprovenance && $image->ready()) {
    $image->Unlock();
    die("*** $0:\n".
	"    $image ready flag is set, this is inconsistent!\n");
}

# See if a web task is tracking this image creation.
$webtask = WebTask->LookupByObject($image->uuid());
if (defined($webtask)) {
    $webtask->AutoStore(1);
}

#
# Be sure to kill off running frisbee. If a node is trying to load that
# image, well tough.
#
if (0) {
    system("$friskiller -k $imageid");
    if ($?) {
	fatal("Could not kill running frisbee for $imageid!");
    }
}

if (-e $filename) {
    #
    # Back it up in case of failure. Note that the frisbee upload server
    # does this, so we do it only for the ssh/nfs case.
    #
    if (!$usefup) {
	system("/bin/mv -f $filename ${filename}.bak");
	if ($?) {
	    fatal("Could not back up $filename");
	}
	$didbackup = 1;
    }
}

#
# We want to truncate the file (we backed it up above), which also
# confirms the user can really create a new file.
#
# XXX The problem is that frisbee upload server does this too, which
# is why we have a lot of zero length backup files. So, in uploader
# mode, make sure the user can create the tmp file that the uploader
# uses.
#
if ($usefup) {
    $tmp = "$filename.tmp";
    if (-e "$tmp") {
	unlink("$tmp") ||
	    fatal("Could not remove $tmp: $!");
    }
} else {
    $tmp = $filename;
}
open(FILE, "> $tmp") or
    fatal("Could not create $tmp: $!");
close(FILE) or
    fatal("Could not truncate $tmp: $!");
#
# XXX this script runs as the user creating the image.
# However, in the uploader case, the uploader runs as the creator of
# the image. In the case those two are not the same, we need to make
# sure that the file we create here is group writable.
#
chmod(0664, $tmp) or
    fatal("Could not make $tmp group writable: $!");

if (! ($isvirtnode || $isec2node)) {
    #
    # Get the disktype for this node
    #
    $node->disktype(\$devtype);
    $node->bootdisk_unit(\$devnum);

    $devtype = $def_devtype
	if (!defined($devtype));
    $devnum = $def_devnum
	if (!defined($devnum));
    $device = "/dev/${devtype}${devnum}";
}

#
# Okay, we want to build up a command line that will run the script on
# on the client node. We use the imageid description to determine what
# slice (or perhaps the entire disk) is going to be zipped up. We do not
# allow arbitrary combos of course. 
#
my $startslice;
my $loadlength;
my $command;

#
# EC2 images use a special command which is hardwired below.
#
if ($isec2node) {
    ;
}
#
# Virtnode images use a version of the old create-image script on the vhost
# XXX needs to be fixed.
#
elsif ($isvirtnode && (!$doprovenance || !$isxenhost)) {
    $command = "$ocreateimage";
    if ($usefup) {
	my $id;
	if ($usepath) {
	    $id = $ofilename;
	} else {
	    $id = $image->pid() . "/" . $image->imagename();
	}
	$command .= " -S $BOSSIP -F $id";
    }

    #
    # XXX Need to add XEN package flag to descriptor.
    #
    if ($isxenhost) {
	if ($image->mbr_version() == 99) {
	    $command .= " -p";
	}
	if ($image->loadpart()) {
	    $command .= " -s " . $image->loadpart();
	}
    }
    $command .= " $node_id";

    if ($usefup || $usessh) {
	$command .= " -";
    } else {
	$command .= " $ofilename";
    }
}
#
# Regular nodes with provenance tracking is turned off, use the old script.
#
elsif (!$doprovenance) {
    $command = "$ocreateimage";
    if ($usefup) {
	my $id;
	if ($usepath) {
	    $id = $ofilename;
	} else {
	    $id = $image->pid() . "/" . $image->imagename();
	}
	$command .= " -S $BOSSIP -F $id";
    }

    $startslice = $image->loadpart();
    $loadlength = $image->loadlength();
    if ($startslice || $loadlength == 1) {
	$command .= " -s $startslice";
    }
    $command .= " $device";

    if ($usefup || $usessh) {
	$command .= " -";
    } else {
	$command .= " $ofilename";
    }
}
#
# Otherwise, use the new script with different argument syntax.
#
else {
    $command = ($isxenhost ? "$createxenimage" : "$createimage");

    #
    # XEN Hosts cannot do provenance/delta without client side update.
    # We need to provide these arguments for backwards compat though.
    #
    if ($isxenhost) {
	$command .= " $node_id";
	if ($usefup || $usessh) {
	    $command .= " -";
	} else {
	    $command .= " $ofilename";
	}
    }

    my $id;
    if ($usefup) {
	$command .= " METHOD=frisbee SERVER=$BOSSIP";

	# if the node has a subboss, use that for downloads
	my $subboss;
	$node->GetSubboss("frisbee", \$subboss);
	if (defined($subboss)) {
	    $command .= " DOWNSERVER=$subboss";
	}

	if ($usepath) {
	    $id = $ofilename;
	} else {
	    $id = $image->pid() . "/" . $image->imagename() . ":$version";
	}
    } else {
	$id = $ofilename;
    }
    $command .= " IMAGENAME=$id";
    if ($srcsigfile) {
	if (!$usefup) {
	    $command .= " OLDSIGFILE=$srcsigfile";
	} else {
	    my $sid = $srcimage->pid() . "/" . $srcimage->imagename() .
		":" . $srcimage->version();
	    $command .= " OLDSIGFILE=$sid,sig";
	}
    }
    if ($dstsigfile) {
	if (!$usefup || $usepath) {
	    $command .= " NEWSIGFILE=$dstsigfile";
	} else {
	    $command .= " NEWSIGFILE=$id,sig";
	}
    }
    if ($deltapct > 0) {
	$zipperopts .= ","
	    if ($zipperopts);
	$zipperopts .= "P=$deltapct";
    }

    $startslice = $image->loadpart();
    $loadlength = $image->loadlength();

    if ($startslice || $loadlength == 1) {
	$command .= " PART=$startslice";
    }
    if (!$isxenhost) {
 	# The XEN host will figure out what device on its own.
	$command .= " DISK=$device";
    }

    if ($zipperopts) {
	$command .= " IZOPTS=$zipperopts";
    }

    #
    # XXX always use ssh for now to get better log info; i.e., all
    # the log info winds up in one logfile.
    #
    $usessh = 1;
}

#
# Go to the background since this is going to take a while.
# 
if (! $foreground) {
    $logfile = Logfile->Create((defined($experiment) ?
				$experiment->gid_idx() : $image->gid_idx()));
    fatal("Could not create a logfile")
	if (!defined($logfile));
    # Mark it open since we are going to start using it right away.
    $logfile->Open();

    # Logfile becomes the current spew.
    $image->SetLogFile($logfile);

    if (my $childpid = TBBackGround($logfile->filename())) {
	#
	# Parent exits normally, except if in waitmode. 
	#
	if (!$waitmode) {
	    print("Your image from $target is being created\n".
		  "You will be notified via email when the image has been\n".
		  "completed, and you can load the image on another node.\n");
	    exit(0);
	}
	print("Waiting for image creation to complete\n");
	print("You may type ^C at anytime; you will be notified via email;\n".
	      "later; you will not actually interrupt image creation.\n");
	
	# Give child a chance to run.
	select(undef, undef, undef, 0.25);
	
	#
	# Reset signal handlers. User can now kill this process, without
	# stopping the child.
	#
	$SIG{TERM} = 'DEFAULT';
	$SIG{INT}  = 'DEFAULT';
	$SIG{QUIT} = 'DEFAULT';

	#
	# Wait until child exits or until user gets bored and types ^C.
	#
	waitpid($childpid, 0);
	
	print("Done. Exited with status: $?\n");
	exit($? >> 8);
    }
}

#
# New process group since we get called from the web interface,
# and so the child does not get zapped if the user types ^C
# in waitmode. 
#
if (! $foreground) {
    POSIX::setsid();
}

#
# From here on out, we should take care to clean up the DB, and
# reboot the source node.
#
$needcleanup = 1;

# Clear the bootlog; see below.
$node->ClearBootLog()
    if (defined($node));

# check_progress state
my $runticks	 = 0;
my $maxticks	 = int($maxwait / $checkwait);
my $reportticks  = int($reportwait / $checkwait);
my $idleticks    = 0;
my $maxidleticks = int($idlewait / $checkwait);
my $lastsize     = 0;
my $result;

#
# XXX initial idle period. This is the period before any write is performed
# to the file. When creating or checking signatures, it can take a long time
# before anything is written to the new image file. So we give them some
# extra time to get the ball rolling.
#
my $maxiidleticks = $maxidleticks;
if ($delta || $signature) {
    $maxiidleticks *= 2;
}

#
# EC2 nodes.
# Run on ops.
#
if ($isec2node) {
    my $safe_target = User::escapeshellarg($target);
    
    my $cmd = "$TB/bin/sshtb -host $CONTROL $EC2SNAP -u $user_uid ".
	"$safe_target $pid $user_uid $imageid $ofilename";
    print STDERR "About to: '$cmd'\n" if (1 || $debug);

    my $SAVEUID	= $UID;
    $EUID = $UID = 0;

    system($cmd);
    fatal("'$cmd' failed")
	if ($?);

    $EUID = $UID = $SAVEUID;
    goto ec2done;
}

#
# Virtnodes.
# Run on vnode host.
#
if ($isvirtnode) {
    #
    # XEN creates a problem; the physical host cannot actually
    # execute a command inside the guest, but we need to run
    # reboot_prepare and reboot it. FreeBSD creates an additional
    # problem in that shutdown has to run to invoke prepare; reboot
    # does not run it, and a shutdown from outside the VM has the
    # sae effect; prepare does not run. What a pain. 
    #
    my $SAVEUID	= $UID;
    $EUID = $UID = 0;

    my $cmd = "$TB/bin/sshtb -n -o ConnectTimeout=10 ".
	"-host $node_id $reboot_prep";
    print STDERR "About to: '$cmd'\n" if ($debug);
    system($cmd);
    fatal("'$cmd' failed")
	if ($?);

    # Mark webtask
    $webtask->status("imaging")
	if (defined($webtask));

    #
    # Now execute command and wait.
    #
    if ($NONFS) {
	$result = run_with_ssh($command, $ofilename);
    } else {
	$result = run_with_ssh($command, undef);
    }
    $EUID = $UID = $SAVEUID;
    goto done;
}

#
# Normal nodes.
# Reboot into admin mode and run the command.
# Note that without a shared FS, we just boot the node into the admin MFS
# and run the command via SSH, capturing the output.
#
my $me           = $0;
my %args         = ();
$args{'name'}    = $me;
$args{'prepare'} = 1;

if ($usessh) {
    #
    # Put the node in admin mode...
    #
    if (!$nomfs) {
	$args{'on'} = 1;
	$args{'clearall'} = 0;
	if (TBAdminMfsSelect(\%args, undef, $node_id)) {
	    $result = "setupfailed";
	    goto done;
	}

	#
	# ...boot it...
	#
	$args{'reboot'} = 1;
	$args{'retry'} = 0;
	$args{'wait'} = 1;
	my @failed = ();
	if (TBAdminMfsBoot(\%args, \@failed, $node_id)) {
	    $result = "setupfailed";
	    goto done;
	}
    }

    # Mark webtask
    $webtask->status("imaging")
	if (defined($webtask));

    #
    # ...execute command and wait!
    # Note: we do not pass the filename, that is part of the key/value
    # string we built up.
    #
    my $SAVEUID	= $UID;
    $EUID = $UID = 0;
    $result = run_with_ssh($command, $filename);
    $EUID = $UID = $SAVEUID;
    if ($result eq "setupfailed") {
	goto done;
    }
} else {
    $args{'command'} = $command;
    $args{'timeout'} = $maxwait + $checkwait;
    $args{'pfunc'}     = \&check_progress;
    $args{'pinterval'} = $checkwait;

    # Mark webtask
    $webtask->status("imaging")
	if (defined($webtask));

    my $retry = 1;
    while ($retry) {
	$retry = 0;
	if (TBAdminMfsRunCmd(\%args, undef, $node_id)) {
	    $result = "setupfailed"
		if (!defined($result));
	}
    }
}

#
# XXX woeful backward compat hack.
# The old client-side script will not recognize the -S and -F options
# we pass in and will exit(-1).  We detect that here and retry with ssh/nfs.
#
# Note that we only do this in the old, non-provenance world since you
# must have an up-to-date MFS to handle provenance.
#
if (!$doprovenance && $usefup && $result eq "255") {
    print STDERR "MFS does not support frisbee upload, falling back on ",
                 $NONFS ? "ssh" : "nfs", "...\n";

    $command = "$ocreateimage ";

    $startslice = $image->loadpart();
    $loadlength = $image->loadlength();
    if ($startslice || $loadlength == 1) {
	$command .= " -s $startslice";
    }
    $command .= " $device";
    if ($usessh) {
	$command .= " -";
    } else {
	$command .= " $ofilename";
    }

    # reset state for check_progress
    $usefup = 0;
    $runticks = 0;
    $idleticks = 0;
    $lastsize = 0;
    $result = undef;

    if ($NONFS) {
	$result = run_with_ssh($command, $ofilename);
    } else {
	$result = run_with_ssh($command, undef);
    }
}

done:

# Grab boot log now. Node will reboot and possibly erase it. We should
# probably come up with a better way to handle this.
my $bootlog;
if ($node->GetBootLog(\$bootlog)) {
    $bootlog = undef;
}

if (! cleanup()) {
    fatal("Problem encountered while cleaning up!\n");
}

#
# If we timed out, if the result code was bad, or if the image size
# grew too large.
#
if ($result eq "setupfailed") {
    fatal("FAILED: Node setup failed ... \n");
}
if ($result eq "timeout") {
    fatal("FAILED: Timed out generating image ... \n");
}
if ($result eq "toobig") {
    fatal("FAILED: Maximum image size ($maximagesize bytes) exceeded ... \n");
}
if ($result != 0) {
    fatal("FAILED: Returned error code $result generating image ... \n");
}

ec2done:
if (defined($webtask)) {
    $webtask->status("finishing");
}

#
# XXX ugh! If we were doing the autodelta thing, we have to check our logfile
# to see if imagezip reported creating a full image instead of a delta.
# Here we are relying on the fact that we are using SSH, that we are in the
# background and thus keeping a log (so the message will wind up in our log),
# and we depend on the format of the message itself.
#
# Ugly? Yes, but worst case one of our assumptions fails and we record an
# image as a delta when it isn't, which is just inefficient when it comes to
# loading the image.
#
if ($delta && $deltapct > 0 && defined($logfile)) {
    if (open(FD, "<" . $logfile->filename())) {
	# XXX should occur early in the log
	my $maxlines = 100;
	while ($maxlines--) {
	    my $line = <FD>;
	    if ($line =~ /^Auto image selection creating (\S+) image/) {
		if ($1 eq "full") {
		    print "Chose to create full image rather than delta.\n";
		    $delta = 0;
		}
		last;
	    }
	}
	close(FD);
    }
}

#
# Update fields in the DB related to the image.
#
# Note that we do not do this for "standard" images since they get uploaded
# into /proj/emulab-ops rather than /usr/testbed. We could automatically move
# the image into place here, but that makes us nervous. We prefer an admin do
# that by hand after testing the new image!
#
my $cname = "$imagepid/$imagename";
$cname .= ":$version"
    if ($doprovenance);
my $tbopsmsg = "";
if ($isglobal && $usepath) {
    $tbopsmsg =
	"Did not update DB state for global image $cname\n".
	"since image was written to '$filename' instead of $TB/images.\n".
	($doprovenance ?
	 "Please run imagerelease when ready for release:\n".
	 "    imagerelease -q $cname\n" :
	 "Move image into place and run:\n".
	 "    $imagevalidate -uq $cname\n");
}
elsif (system("$imagevalidate -uq $cname") != 0) {
    $tbopsmsg =
	"DB state update for image $cname failed, try again with:\n".
	"    $imagevalidate -u $cname\n";
}
if ($tbopsmsg) {
    SENDMAIL($TBOPS,
	     "Image DB state update failure for $cname",
	     $tbopsmsg,
	     $TBOPS,
	     undef,
	     ());
}

print "$cname: ";
print "delta "
    if ($delta);
print "image creation succeeded, written to $filename.\n";
#      "Final size: " . (stat($filename))[7] . " bytes.\n";

# Append bootlog (which has prepare output)
if (defined($bootlog)) {
    print "\n\n";
    print "------------------ Prepare Output ----------------\n";
    print "$bootlog\n";
}

SENDMAIL("$user_name <$user_email>",
	 "Image Creation on $target Completed: $imagepid/$imagename",
	 "Image creation on $target has completed. As you requested, the\n".
	 "image has been written to $filename.\n".
	 "You may now os_load this image on other nodes in your experiment.\n",
	 "$user_name <$user_email>",
	 "Bcc: $TBLOGS",
	 defined($logfile) ? ($logfile->filename()) : ()) if (!$noemail);

if (defined($logfile)) {
    # Close up the log file so the webpage stops.
    $logfile->Close();
    $image->ClearLogFile();
}
if (defined($webtask)) {
    $webtask->status("ready");
    $webtask->Exited(0);
}
#
# If we created a delta image, set it in the DB
#
if ($delta) {
    $image->SetDelta(1);
}

#
# Normal images are immediately marked as "released" (and ready),
# but global system images are just marked ready, and must be explicitly
# released.
#
$image->MarkReady();
if (! ($isglobal && $pid eq TBOPSPID()) || !$doprovenance) {
    if ($image->Release()) {
	$image->Unlock();
	exit(1);
    }
}
$image->Unlock();
exit(0);

sub cleanup ()
{
    $needcleanup = 0;

    if (defined($hacksigfile)) {
	unlink($hacksigfile);
    }

    if ($isvirtnode || $isec2node) {
	#
	# Nothing to do; the clientside script rebooted the container.
	#
	return 1;
    }

    #
    # Turn admin mode back off and reboot back to the old OS
    #
    if (!$nomfs) {
	my %args          = ();
	$args{'name'}     = $me;
	$args{'on'}       = 0;
	$args{'clearall'} = 0;
	if (TBAdminMfsSelect(\%args, undef, $node_id)) {
	    print("*** $me:\n".
		  "    Could not turn admin mode off for $node_id!\n");
	    return 0;
	}

	%args           = ();
	$args{'name'}   = $me;
	$args{'on'}     = 0;
	$args{'reboot'} = 1;
	$args{'wait'}   = 0;
	if (TBAdminMfsBoot(\%args, undef, $node_id)) {
	    print("*** $me:\n".
		  "    Failed to reboot $node_id on cleanup!\n");
	    return 0;
	}
    }

    return 1;
}

sub fatal($)
{
    my($mesg) = $_[0];

    print "$mesg\n";

    if ($needcleanup && !cleanup()) {
        print "Encountered problems cleaning up!\n";
    }
    
    #
    # Send a message to the testbed list. 
    #
    SENDMAIL("$user_name <$user_email>",
	     "Image Creation Failure on $target: $imagepid/$imagename:$version",
	     $mesg,
	     "$user_name <$user_email>",
	     "Cc: $TBOPS",
	     defined($logfile) ? ($logfile->filename()) : ());
    
    if (defined($logfile)) {
	# Close up the log file so the webpage stops.
	$logfile->Close();
	$image->ClearLogFile();
    }
    
    if (defined($webtask)) {
	$webtask->status("failed");
	$webtask->imagesize(0);
	$webtask->Exited(1);
    }
    $image->Unlock()
	if ($needunlock);
    # Restore old image file. 
    if ($didbackup) {
	system("/bin/mv -f ${filename}.bak $filename");
    }
    exit(-1);
}

#
# Check progress of image creation by periodically checking the image size.
#
# Called every $checkwait seconds.
# Reports progress every $reportwait seconds.
# Gives up after $idlewait seconds without a size change.
#
sub check_progress($$)
{
    my (undef, $statusp) = @_;

    if ($runticks == 0) {
	print "$node_id: started image capture for '$filename', ".
	    "waiting up to " . int($maxwait/60) . " minutes total or ".
	    int($idlewait/60) . " minutes idle.\n";
    }

    #
    # XXX frisbee uploader uploads into a temporary file and then moves
    # it into place. So track that tmp file here.
    #
    my $fname = $filename;
    if ($usefup) {
	$fname .= ".tmp";
    }

    #
    # Command has finished for better or worse, record status and finish.
    #
    if (defined($statusp) && $statusp->{$node_id} ne "none") {
	$result = $statusp->{$node_id};
	print "$node_id: image capture has completed: status='$result'\n";
	return 0;
    }

    #
    # Has run too long
    #
    $runticks++;
    if ($runticks >= $maxticks) {
	$result = "timeout";
	print "$node_id: image capture has completed: timeout\n";
	return 0;
    }

    #
    # See if imagezip on the node is making progress.  If not, we need to
    # check the idle timer and timeout if we have taken too long.
    #
    # Also, check to see if the (somewhat arbitrary) maximum filesize has 
    # been exceeded.
    #
    my $cursize = (stat($fname))[7];
    if (!defined($cursize)) {
	#
	# XXX avoid an ugly race.
	# When done, frisuploadd moves foo.tmp -> foo
	# If we didn't find foo.tmp, try foo now.
	#
	if ($usefup) {
	    $fname =~ s/\.tmp$//;
	    $cursize = (stat($fname))[7];
	}
	#
	# XXX avoid an ugly uninitialized value.
	# This should not happen, since we created the file,
	# but just in case, if the file doesn't exist set the size to 0.
	# We will eventually timeout.
	#
	if (!defined($cursize)) {
	    $cursize = 0;
	}
    }
    if ($cursize > $maximagesize) {
	$result = "toobig";
	print "$node_id: image capture has completed: image too big\n";
	return 0;
    }
    if ($cursize == $lastsize) {
	$idleticks++;
	if ($idleticks >= ($cursize > 0 ? $maxidleticks : $maxiidleticks)) {
	    $result = "timeout";
	    print "$node_id: image capture has completed: idle timeout\n";
	    return 0;
	}
    } else {
	$idleticks = 0;
    }
    $lastsize = $cursize;
    
    if (($runticks % $reportticks) == 0) {
	my $curtdiff = int($runticks * $checkwait / 60);
	print "$node_id: still waiting ...".
	    " it has been ". $curtdiff ." minutes.".
	    " Current image size: $cursize bytes.\n";
    }
    if (defined($webtask)) {
	$webtask->imagesize($cursize / 1024);
    }
    return 1;
}

sub run_with_ssh($$)
{
    my ($cmd,$output) = @_;
    my $stat = undef;
    $node_id = $node->phys_nodeid()
	if ($isvirtnode);

    $cmd = "$TB/bin/sshtb -n -host $node_id $cmd";
    if (defined($output)) {
	$cmd .= " > $output";
    }
    print STDERR "About to: '$cmd' as uid ".
	($onsharednode ? 0 : $UID) . "\n" if ($debug);

    my $mypid = fork();
    if ($mypid < 0) {
	return "setupfailed";
    }

    #
    # Child. Just do it.
    #
    # If this is a virtnode on a shared node, we want to flip
    # back to root so that we run the ssh as root. 
    #
    if ($onsharednode) {
	$EUID = $UID = 0;
    }

    if ($mypid == 0) {
	my $stat = 0;
	if (system($cmd)) {
	    $stat = $?;
	}
	if ($stat & 127) {
	    # died with a signal, return the signal
	    exit($stat & 127);
	}
	exit($stat >> 8);
    }

    #
    # Parent.  Wait for ssh to finish, reporting periodic progress
    # as TBAdminMfsRunCmd would do.
    #
    my $endtime = time() + $maxwait + $checkwait;
    while (1) {
	my $kid = waitpid($mypid, &WNOHANG);
	# ssh finished
	if ($kid == $mypid) {
	    $stat = $?;
	    if ($stat & 127) {
		# died with a signal, return the signal
		$stat = $stat & 127;
	    } else {
		# else return the exit code
		$stat = $stat >> 8;
	    }
	    last;
	}

	# huh?
	if ($kid == -1) {
	    $stat = -1;
	    last;
	}

	# check on progress
	if (!check_progress(undef, undef)) {
	    $stat = $result;
	    last;
	}

	# wait for awhile
	sleep($checkwait);
	if (time() >= $endtime) {
	    $stat = "timeout";
	    last;
	}
    }

    return $stat;
}
